package main

import (
    "fmt"
    "net/http"
    "sync"
)

// Function to make requests with a given concurrency limit
func makeRequest(req *http.Request, concurrency int) {
    client := &http.Client{}

    // Create a buffered channel (semaphore) to limit concurrency
    semaphore := make(chan struct{}, concurrency)

    var wg sync.WaitGroup

    for i := 0; i < concurrency; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()

            // Acquire permission to make a request
            semaphore <- struct{}{}

            // Make the request
            resp, err := client.Do(req)
            if err != nil {
                fmt.Println("Request error:", err)
                <-semaphore
                return
            }
            defer resp.Body.Close()

            // Release the semaphore
            <-semaphore

            fmt.Printf("Request %d completed with status code %d\n", i, resp.StatusCode)
        }(i)
    }

    // Wait until all goroutines complete
    wg.Wait()
    fmt.Println("All requests complete")
}

// Then use it like:
func main() {
    req, _ := http.NewRequest("GET", "http://example.com", nil)
    makeRequest(req, 10)
}
